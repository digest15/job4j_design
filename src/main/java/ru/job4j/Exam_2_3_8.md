# 1. Что такое SQL?

SQL - это декларативный язык программирования, который используется для создания, модификации и управления данными 
в реляционной БД, управляемой системой управления базами данных (СУБД). С помощью SQL-запросов можно добавлять, 
изменять, получать или удалять данные из БД.


# 2. Что такое DML и DDL?

Операторы SQL делятся на:

* Операторы определения данных (Data Definition Language, DDL):
  - CREATE создаёт объект базы данных (саму базу, таблицу, представление, пользователя и так далее),
  - ALTER изменяет объект,
  - DROP удаляет объект;
* Операторы манипуляции данными (Data Manipulation Language, DML):
  - SELECT выбирает данные, удовлетворяющие заданным условиям,
  - INSERT добавляет новые данные,
  - UPDATE изменяет существующие данные,
  - DELETE удаляет данные;
* Операторы определения доступа к данным (Data Control Language, DCL):
  - GRANT предоставляет пользователю (группе) разрешения на определённые операции с объектом,
  - REVOKE отзывает ранее выданные разрешения,
  - DENY задаёт запрет, имеющий приоритет над разрешением;
* Операторы управления транзакциями (Transaction Control Language, TCL):
  - COMMIT применяет транзакцию,
  - ROLLBACK откатывает все изменения, сделанные в контексте текущей транзакции,
  - SAVEPOINT делит транзакцию на более мелкие участки.


# 3. Что такое первичный ключ?

Для таблиц существует понятие первичный ключ (primary key) - это поле в таблице, однозначно идентифицирующее 
каждую строку (запись) в таблице БД. Первичный ключ должен содержать уникальные значения. Также не может содержать null. 
В таблице может быть только один первичный ключ. Ключ может состоять из одного, и более, полей. Первичный ключ, 
состоящий из нескольких полей, называется составным ключом.
По сути это ограничение - проверка условий.


# 4. Что такое внешний ключ?

Ограничение внешнего ключа указывает, что значения столбца (или группы столбцов) должны соответствовать значениям
в некоторой строке другой таблицы. Это называется ссылочной целостностью двух связанных таблиц.

Предназначен для связи таблиц, для ограничения на значения этих таблиц. 
Внешний ключ – атрибут таблицы, который содержит значения из другой таблицы, что позволяет связать записи между собой.


# 5. Какие виды связей между таблицами существуют и как они организуются?

* Многие ко многим. 
  - Такая связь организуется через дополнительную связующую таблицу, которая содержит внешние ключи, ссылающиеся 
  на первичные ключи связуемых таблиц.

* Один ко многим.
  - Таблица имеющая отношение "многим" содержит внешний ключ на первичный ключ таблицы с отношением "один".

* Один к одному.
  - Реализуется по-разному, в зависимости от направления связи. 
  При однонаправленной связи реализуется как связь "Один ко многим" с дополнительным ограничением на уникльность значения
  внешнего ключа.
  При двунаправленной как связь "многие ко многим" с дополнительными ограничениями на уникальность внешних ключей 
  связующей таблицы.


# 6. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).

* Вставка строк в таблицу, в общем виде, осуществляется следующей командой:
  - INSERT INTO имя_таблицы [ AS псевдоним ] [ ( имя_столбца [, ...] ) ] { VALUES ( { выражение } [, ...]  ) | запрос }

* Удаление строк из таблицы:
  - DELETE FROM имя_таблицы [ * ] [ [ AS ] псевдоним ] [ WHERE условие ]

* Обновление/изменение строк таблицы:
  - UPDATE [ ONLY ] имя_таблицы [ * ] [ [ AS ] псевдоним ] SET { имя_столбца = { выражение | DEFAULT } [ WHERE условие ]


# 7. Что такое нормализация БД?

https://habr.com/ru/post/254773/

Нормализация БД – это процесс организации данных определенным образом и рекомендации по проектированию. Т.е. таблицы и 
связи между ними (отношения) создаются в соответствии с правилами. В результате обеспечивается некоторый уровень 
безопасности данных. К тому же устраняются несогласованные зависимости и избыточность

* Цель нормализации: исключить избыточное дублирование данных, которое является причиной аномалий, возникших 
при добавлении, редактировании и удалении кортежей (строк таблицы).

* Аномалией называется такая ситуация в таблице БД, которая приводит к противоречию в БД либо существенно усложняет 
обработку БД. Причиной является излишнее дублирование данных в таблице, которое вызывается наличием функциональных зависимостей от не ключевых атрибутов.

* Аномалии-модификации проявляются в том, что изменение одних данных может повлечь просмотр всей таблицы и 
соответствующее изменение некоторых записей таблицы.

* Аномалии-удаления — при удалении какого либо кортежа из таблицы может пропасть информация, которая не связана 
на прямую с удаляемой записью.

* Аномалии-добавления возникают, когда информацию в таблицу нельзя поместить, пока она не полная, либо вставка записи 
требует дополнительного просмотра таблицы.

Существует 7 нормальных форм:

1. 1НФ. Первая нормальная форма.
   - Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать 
   только скалярные значения. Не должно быть повторений строк в таблице.

2. 2НФ. Вторая нормальная форма.
   - Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от 
   Первичного Ключа(ПК). 
   - Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, 
   от которого можно также вывести данную функциональную зависимость

3. 3НФ. Третья нормальная форма.
   - Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит 
   от первичного ключа. Проще говоря, второе правило требует выносить все не ключевые поля, содержимое которых может 
   относиться к нескольким записям таблицы в отдельные таблицы.

4. НФБК. Нормальная форма Бойса-Кодда.
   - Отношение находится в НФБК, когда каждая нетривиальная и неприводимая слева функциональная зависимость обладает 
   потенциальным ключом в качестве детерминанта.
   - Для отношений, имеющих один потенциальный ключ (первичный), НФБК является 3НФ.
   - Определение 3НФ не совсем подходит для следующих отношений:
     - отношение имеет два или более потенциальных ключа; 
     - два и более потенциальных ключа являются составными; 
     - они пересекаются, т.е. имеют хотя бы один общий атрибут.

5. 4НФ. Четвертая нормальная форма.
   - Отношение находится в 4НФ, если оно находится в НФБК и все нетривиальные многозначные зависимости фактически 
   являются функциональными зависимостями от ее потенциальных ключей.

6. 5НФ. Пятая нормальная форма.
   - Отношения находятся в 5НФ, если оно находится в 4НФ и отсутствуют сложные зависимые соединения между атрибутами.
     Если «Атрибут_1» зависит от «Атрибута_2», а «Атрибут_2» в свою очередь зависит от «Атрибута_3», а «Атрибут_3» 
   зависит от «Атрибута_1», то все три атрибута обязательно входят в один кортеж. 
   - Это очень жесткое требование, которое можно выполнить лишь при дополнительных условиях. На практике трудно найти 
   пример реализации этого требования в чистом виде.

7. ДКНФ. Доменно-ключевая нормальная форма.
   - Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение является 
   логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную отношения. 
   - Ограничение домена – ограничение, предписывающее использовать для определённого атрибута значения только из 
   некоторого заданного домена. Ограничение по своей сути является заданием перечня 
   (или логического эквивалента перечня) допустимых значений типа и объявлением о том, что указанный атрибут имеет 
   данный тип. 
   - Ограничение ключа – ограничение, утверждающее, что некоторый атрибут или комбинация атрибутов является 
   потенциальным ключом. 
   - Любая переменная отношения, находящаяся в ДКНФ, обязательно находится в 5НФ. Однако не любую переменную 
   отношения можно привести к ДКНФ.

8. 6НФ. Шестая нормальная форма.
   - Переменная отношения находится в шестой нормальной форме тогда и только тогда, когда она удовлетворяет всем 
   нетривиальным зависимостям соединения. Из определения следует, что переменная находится в 6НФ тогда и только тогда, 
   когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Каждая переменная 
   отношения, которая находится в 6НФ, также находится и в 5НФ. 
   - Идея «декомпозиции до конца» выдвигалась до начала исследований в области хронологических данных, но не нашла 
   поддержки. Однако для хронологических баз данных максимально возможная декомпозиция позволяет бороться с 
   избыточностью и упрощает поддержание целостности базы данных. 
   - Для хронологических баз данных определены U_операторы, которые распаковывают отношения по указанным атрибутам, 
   выполняют соответствующую операцию и упаковывают полученный результат. В данном примере соединение проекций 
   отношения должно производится при помощи оператора U_JOIN.


# 8. Что такое денормализация БД? Для чего она нужна?

Это стратегия, применимая к уже нормализованной базе данных с целью повышения ее производительности. 
Смысл этого действия — поместить избыточные данные туда, где они смогут принести максимальную пользу. 
Для этого можно использовать дополнительные поля в уже существующих таблицах, добавлять новые таблицы или даже 
создавать новые экземпляры существующих таблиц. Логика в том, чтобы снизить время исполнения определенных запросов 
через упрощение доступа к данным или через создание таблиц с результатами отчетов, построенных на основании 
исходных данных.

Цели:
- Для повышения производительности запросов.
- Сделать БД более удобной в управлении.
- Упростить и ускорить составление отчетов.

Приемы:
- Хранение производных данных - данные вычислений
- Использование предварительно соединенных таблиц - хранения значений из другой таблицы в колонках текущей
- Использование жестко зафиксированных значений - хранение констант в колонках таблицы
- Хранение данных у главной записи - хранение детальных записей в таблице для главных
- Добавление коротко замкнутых ключей - хранение ключей более низких уровней замкнутости

Минусы:
- дополнительное место для хранения.
- дополнительная документация.
- возможные аномалии данных.
- приходится писать больше кода.
- более медленные операции обновления


# 9. Что такое кластерный и некластерный индексы?

Кластерный индекс – это индекс, который физически упорядочивает данные (фактически биты на диске) определенным образом. 
Когда в таблицу поступают новые данные, то они сохраняются в том же порядке.
т.е. по сути кластерный индекс это упорядоченные данные самой таблицы.

Некластерные индексы – это индексы, которые хранят отдельный список упорядочивания, в котором есть указатели на 
физические строки.
т.е. это отдельная, дополнительная упорядоченная структура данных. Они могут использовать другой порядок данных. 
Это придумано для ускорения выборки данных определенных запросов.


# 10. Какие типы соединений (join) таблиц существуют? В чем их разница?

* JOIN – левая_таблица JOIN правая_таблица ON условия_соединения
  - Из строк левой_таблицы и правой_таблицы объединяются и возвращаются только те строки, по которым выполняются 
  условия_соединения.

* LEFT JOIN – левая_таблица LEFT JOIN правая_таблица ON условия_соединения
  - Возвращаются все строки левой_таблицы (ключевое слово LEFT). Данными правой_таблицы дополняются только те строки 
  левой_таблицы, для которых выполняются условия_соединения. Для недостающих данных вместо строк правой_таблицы 
  вставляются NULL-значения.

* RIGHT JOIN – левая_таблица RIGHT JOIN правая_таблица ON условия_соединения
  - Возвращаются все строки правой_таблицы (ключевое слово RIGHT). Данными левой_таблицы дополняются только те строки 
  правой_таблицы, для которых выполняются условия_соединения. Для недостающих данных вместо строк левой_таблицы 
  вставляются NULL-значения.
  
* FULL JOIN – левая_таблица FULL JOIN правая_таблица ON условия_соединения
  - Возвращаются все строки левой_таблицы и правой_таблицы. Если для строк левой_таблицы и правой_таблицы выполняются 
  условия_соединения, то они объединяются в одну строку. Для строк, для которых не выполняются условия_соединения, 
  NULL-значения вставляются на место левой_таблицы, либо на место правой_таблицы, в зависимости от того данных какой 
  таблицы в строке не имеется.
  
* CROSS JOIN – левая_таблица CROSS JOIN правая_таблица
  - Объединение каждой строки левой_таблицы со всеми строками правой_таблицы. Этот вид соединения иногда называют 
  декартовым произведением.


# 11. Что такое SQL курсор?

1. Курсор – это область в памяти БД, предназначена для хранения последнего оператор SQL. Если текущий оператор – 
запрос к БД, то в памяти хранится и строка данных запроса. Она называется текущим значением или же – 
текущей строкой курсора. Данная область в памяти поименована и доступна нам для вызова.

2. (Больше для программистов) Курсор – это объект, который позволяет отдельно обрабатывать строки из результирующего 
набора данных, который возвращается оператором SELECT. Строки при этом можно перебирать последовательно, 
с первой до последней.

Благодаря курсорам выборка данных запросом может быть выполнена не полностью, а частично, по мере потребления данных 
курсором в память из БД будут подгружаться новые строки.


# 12. Опишите шаги по созданию и использованию курсора.

1. BEGIN; 
   - Открываем транзакцию

2. DECLARE [cursor_name] [[NO] SCROLL] CURSOR FOR [query];
   - Описываем курсор и запрос для которого он будет создат
   
3. FETCH [FORWARD | BACKWARD] [direction (rows)] FROM [cursor_name]; 
| MOVE [FORWARD | BACKWARD] [direction (rows)] FROM [cursor_name];
   - Делаем выборку из курсора или перемещаемся по нему
   
4. CLOSE cursor_name;
   - Закрываем курсор

5. COMMIT;
   - Закрываем транзакцию


# 13. Что такое транзакция?

Транзакция – это совокупность операций или шагов, которые представляют собой логически неделимую единицу. 
При этом операции могут быть выполнены или целиком и успешно, или же не выполнены вообще.

Суть транзакции в том, что она объединяет последовательность действий в одну операцию «всё или ничего». 
Промежуточные состояния внутри последовательности не видны другим транзакциям, и если что-то помешает успешно 
завершить транзакцию, ни один из результатов этих действий не сохранится.

Свойства транзакции ACID:

1. Atomicity (атомарность);
   - означает, что транзакция не может быть выполнена частично. Таким образом, всегда все операции транзакции будут 
   выполнены (все и до конца) или же не будут выполнены (ни одна, т.е. все изменения данных будут отменены).

2. Consistency (согласованность);
   - означает, что успешно завершенная транзакция гарантированно сохраняет согласованность БД, 
   т.е. фиксируются только допустимые результаты изменения данных (они не должны противоречить никаким ограничениям
   
3. Isolation (изолированность);
   - означает, что несколько выполняемых параллельно транзакций не должны влиять на результат выполнения друг друга.
   
4. Durability (устойчивость).
   - означает, что СУБД самостоятельно решает все «внутренние проблемы» и гарантирует, что после завершения транзакции 
   (как успешного, так и неуспешного), все необходимые изменения были или зафиксированы, или отменены и 
   что БД не окажется в некотором «промежуточном состоянии».

Аномалии транзакций:

1. Потерянное обновление 
   – в этом случае сохраняются только те изменения данных, которые были выполнены позже всего.

2. Грязное чтение 
   - в этом случае становится доступным временное состояние данных, которые в дальнейшем будут удалены или изменены 
   в силу отмены работавшей с ними транзакциями.

3. Неповторяющееся чтение
   - в этом случае происходит чтение одних и тех же данных за время работы транзакции (т.е. при повторном чтении ранее 
   прочитанных данных мы получим новый результат).

4. Фантомное чтение
   - в этом случае происходит изменение количества строк, которые подпадают под выборку 
   (в силу добавления или удаления строк).

Уровни изоляции транзакций
1. Read uncommitted (чтение незафиксированных данных)
2. Read committed (чтение фиксированных данных)
3. Repeatable read (повторяющееся чтение)
4. Serializable (упорядочиваемость)

    
# 14. Что такое триггер? Какие типы триггеров Вы знаете?

Триггер – специальный объект БД, описывающий перечень действий, которые необходимо автоматически выполнить 
при наступлении указанного события.

Группы событий триггеров:
1. BEFORE (до выполнения операции);
2. INSTEAD OF (вместо выполнения операции);
3. AFTER (после выполнения операции).

Уровни триггеров:
1. Триггеры уровня строки(row) запускаются каждый раз заново для каждой отдельной строки (записи таблицы), 
которая будет затронута SQL-запросом; 
2. Триггеры уровня запроса(statement) запускаются один раз для всего SQL-запроса.


# 15. В чем разница между where и having?

- where - фильтрует данные на уровне строк выборки

- having - фильтрует данные на уровне сгруппированных строк, т.е. когда уже произошло какое-то вычисление над строками.
Группировка происходит после выборки данных и после их фильтрации выражением where. А уже после группировки происходит
фильтрация выражением having


# 16. Что такое подзапрос (sub-query)?

Это запрос внутри запроса. Могут служить как источник данных для запроса или как значение условия в отборах, 
или как значение поля, если это скалярный запрос.


# 17. Что такое union?

Это операция объединения результатов двух запросов. UNION по сути добавляет результаты второго запроса 
к результатам первого.


# 18. Что такое group by?

GROUP BY — Задает по какому столбцу результата запроса будет произведена агрегация.
Без использования агрегатной функции по сути выдает набор различающихся значений столбцов, результат аналогичен
использованию DISTINCT.


# 19. Что такое хранимые процедуры?

Хранимая процедура – это подпрограмма (она может принимать параметры), которая предназначена выполнять ряд операций 
с данными и структурами БД. Хранится на стороне БД и доступна как для вызова из других процедур и триггеров, 
а также может исполняться самостоятельно.

Хранимая функция – это подпрограмма (она может принимать параметры), которая расширяет возможности SQL и работает 
по аналогии со встроенными в СУБД функциям. При этом функция обязана возвращать значения.

Если говорить упрощенно, то хранимая процедура - это подпрограмма, которую можно вызвать напрямую или из других 
подпрограмм, и при этом она выполняет полезные действия. Функция же расширяет возможности СУБД и предназначена 
для упрощения повторяющихся операций.

Синтаксис:

    CREATE [ OR REPLACE ] PROCEDURE
    имя ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ { DEFAULT | = } выражение_по_умолчанию ] [, ...] ] )
    { LANGUAGE имя_языка
    | TRANSFORM { FOR TYPE имя_типа } [, ... ]
    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
    | SET параметр_конфигурации { TO значение | = значение | FROM CURRENT }
    | AS 'определение'
    | AS 'объектный_файл', 'объектный_символ'
    | тело_sql
    } ...


# 20. Что такое view (Представление)?

Это сохраненный, именнованный запрос. Позволяет упростить работу с часто используемыми запросами, обращаясь с ними как
таблицами БД.

Синтаксис:

    CREATE VIEW имя_запроса AS текст_запроса;


# 21. Что такое JDBC?

Это спецификация API для работы с реляционными базами данных.


# 22. Что нужно для работы с той или иной БД?

Для работы с той или иной базой данных существует понятие драйвера. Драйвер – это то, что позволяет работать с бд 
(поддерживать подключения, выполнять запросы и т.д.). Для каждой БД есть свой драйвер. Чтобы добавить драйвер в проект 
необходимо добавить зависимость на этот самый драйвер.


# 23. Как зарегистрировать драйвер?

Необходимо выполнить следующий код:
    
    Class.forName("<полный путь да класса драйвера>");

Но в последних спецификациях JDBC виртуальная машина Java сама "подтягивает/подключает" драйвер, если он находиться в 
classpath. Если же в classpath есть несколько (более одного) драйверов, то для того корректного подключения 
определенного драйвера, необходимо зарегистрироват его вручную, при помощи вышеуказанного кода.


# 24. Как получить Connection?

    try (Connection connection = DriverManager.getConnection(url, login, password)) {
    ...
    }

Так как `connection` это ресурс, то с ним лучше работать в блоке try-с ресурсами.


# 25.Что такое Statement, PreparedStatement? В чем разница между ними?

Statement - это объект спецификации JDBC, представляющий статическое описание запроса.

PreparedStatement - это объект спецификации JDBC, представляющий описание запроса, который может принимать параметры.

Отличие как раз в параметрах. Если нужно выполнить два запроса, в которых разница только, например, в значении
отбора, то в случае `Statement` нужно создать новый запрос, содержащий новый текст запроса, а в случае  
`PreparedStatement` нужно будет только указать новое значение параметра.

`PreparedStatement` дает следующие преимущества:
- Производительность - такие запросы не нуждаются в перекомпилировании на уровне БД.
- Безопасность - обычно, чтобы изменить запрос без параметров, применяется техника замены текста запроса, полученного 
от пользователя. Такой подход создает риск sql-инъекций.


# 26. Что такое ResultSet?

ResultSet - это объект спецификации JDBC, представляющий результат выполнения запроса.


# 27. В чем разница между методами execute, executeUpdate, executeQuery?

`executeQuery` - метод спецификации JDBC, выполняющий запрос на получение данных и возвращает `ResultSet`.

`executeUpdate` - метод спецификации JDBC, выполняющий запрос на обновление данных (DML) и возвращает 
количество измененных строк. Для операций работы с таблицами всегда возвращает 0.

`execute` - это метод спецификации JDBC, выполняющий любые команды SQL. 

Возвращает `boolean`:

    - true - если результатом выполнения является ResultSet (то есть был выполнен SELECT запрос)
    - false - если результатом является int (количество изменённых строк)

Получить `ResultSet` или количество строк мы можем с помощью последующего вызова 

    - getUpdateCount()
    - getResultSet()


# 28. Можно ли использовать возвращаемое значение execute() для проверки, что что-то обновилось?

Нет


# 29. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?

    try (ResultSet generatedKeys = statement.getGeneratedKeys()) {
        if (generatedKeys.next()) {
            city.setId(generatedKeys.getInt(1));
        }
    }


# 30. Для чего используется конструкция try-with-resources?

Для автоматического закрытия ресурсов которые реализуют интерфейс `AutoCloseable`.
